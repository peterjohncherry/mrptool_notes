\documentclass[12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{array}
\usepackage{booktabs}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage{longtable}
\usepackage{calc}
\usepackage{setspace}
\usepackage{hhline}
\usepackage{ifthen}
\usepackage{lscape}
\usepackage{pdfpages}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 bottom=20mm,
 right=20mm,
 }
\usepackage{cite}
\linespread{1.3}

\begin{document}
\section{Tensor Operator (TensOp)}
In most cases the ranges of the molecular orbital indexes can be split into a
number of different subranges, which enable us to define each of the operator
tensors as the sum of a number of different blocks, each one associated with a
different combination of these subranges. Decomposing the tensors in this
manner reduces the maximum size of the data structure the computer has to deal
with at any one time. Block decomposition also facilitates the implementation
of symmetry, as many blocks are either equivalent to one another or connected
via some simple transformation. This is particularly relevant in the
relativistic case, where Kramers symmetry can potentially be used to ensure
that the size of the blocks we deal with is no larger than those encountered in
the non-relativistic case.\\

\noindent Before proceeding further it is worth mentioning that the design of
the basic tensor operator object is heavily informed by the functionality
required of the algebraic manipulation routines. For these manipulation 
routines to make sense it is necessary to be very precise about the 
definition of the tensors. Consequently, some of the exposition will 
seem tedious, and the design choices unnatural, at least until the algorithms in the main algebraic
manipulator are discussed.\\ 

\noindent The design of this object is easiest explained by example. Consider an operator; $\hat{Q}$,
which may be written in second quantized form as
\begin{equation}
\hat{Q} =  \sum_{i}^{R^{i}}\sum_{j}^{R^{j}}\sum_{k}^{R^{k}}\sum_{l}^{R^{l}} \hat{a}^{\dagger}_{i} \hat{a}^{\dagger}_{j} \hat{a}_{k} \hat{a}_{l} Q_{ijkl}.
\label{eqn:Q_def}
\end{equation}
\noindent  The coefficients,
$Q_{ijkl}$, can be thought of as elements of a tensor $\mathbf{Q}$, which is
the representation of the operator $\hat{Q}$ in the molecular orbital basis.
I shall refer to such tensors as operator tensors. The $R^{i}$ is just the set
of values over which index $i$ runs (note the range is index specific). This
$R^{i}$ can be broken down into $N_{block}$ disjoint subsets or sub ranges, i.e.,
\begin{equation}
R^{i} = r_{1}^{i} \cup r_{2}^{i} \cup r_{3}^{i} \cup ... = \bigcup^{N_{block}}_{\mu} r_{\mu}^{i}
\end{equation}
\noindent A range block, $\mathbf{B}$, specifies the combinations of indexes which lie within some specified ranges. For example, the (ordered) set
of sub ranges, $\{ r_{\mu},\text{\ } r_{\nu}, \text{\ }r_{\xi}, \text{\ } r_{\chi} \}$, defines range block $B^{\mu\nu\xi\chi}$, which specifies the set
of ranges.
\begin{equation}
B^{\mu\nu\xi\chi} :=  \{ \{i,j,k,l\}  \text{\ }|  \text{\ }i \in \ r_{\mu}^{i} , \text{\ } j \in r_{\nu}^{j},  \text{\ } k \in r_{\xi}^{k},  \text{\ }l\in r^{l}_{\chi} \}.
\end{equation}
The components, $ Q_{ijkl}^{b}$, of a tensor block, $\mathbf{Q}^{b}$ are those blocks which satisfy
\begin{equation}
Q_{ijkl} \in \mathbf{Q}^{b} \text{ \ \ iff \ \ }  \{ i, j, k, l \} \in b   
\end{equation}
using this notation we can rewrite (\ref{eqn:Q_def}) as 
\begin{equation}
\hat{Q} =  \sum_{b}^{\{B\}} \sum_{\{i,j,k,l\}}^{b }
\hat{a}^{\dagger}_{i} \hat{a}^{\dagger}_{j} \hat{a}_{k} \hat{a}_{l} Q_{ijkl}.
\label{eqn:Q_block_def}
\end{equation}
\noindent 

\noindent For each operator $\hat{Q}$, we store a single \emph{TensOp} object, which corresponding to
a molecular orbital tensor $\mathbf{Q}$. This object contains a list of blocks, $Q^{b}$, information about which is stored
in  \emph{CtrTensorPart} objects. To facilitate the exploitation of symmetry and sparsity, the task list generated by the program 
only contains instructions referring to tensor blocks, never the full operators themselves.

\subsection { Block symmetry and sparsity }

Some blocks of the tensor can be obtained by transforming other blocks. How the program exploits this is best explained
through a series of examples.\\ 

\noindent Consider two tensor blocks $Q^{b1}$ and $Q^{b2}$ between which there is the relation
\begin{equation}
Q^{b1}_{ijkl} = Q^{b2}_{ijlk}\rho,
\label{eqn:Qsymm}
\end{equation}
where $b1 = B^{\xi\xi\chi\xi }$, $b2 := B^{\xi\xi\xi\chi }$, and $\rho$ is some constant factor. This is a special case were the ranges $r^{\xi}$ and $r^{\chi}$ have
the same length:
\begin{equation}
\text{card}(r^{\xi}) = \text{card}(r^{\chi}).
\end{equation}
This case regularly occurs when dealing with spin symmetry. Here an element of block $Q^{b1}$ is equal to an element of block $Q^{b2}$ with the last two indexes interchanged.
Therefore, we do not need to store both blocks; operations on $Q^{b2}$ are equivalent to operations on $Q^{b1}$ preceeded by a transformation.\\

\noindent Now consider a third, unrelated tensor block $R^{b3}$, where $b3 := \{\xi, \xi, \chi, \xi \nu, \nu \}$. 
This tensor block is large, and $r^{\nu}$ has far greater extent than $r^{\chi}$, i.e.,
\begin{equation}
\text{card}(r^{\nu}) >> \text{card}(r^{\chi})
\end{equation}

\noindent For example, consider calculation of elements of a tensor $\mathbf{X}$ from contractions between tensors $\mathbf{Q}$ and $\mathbf{R}$;
\begin{equation}
X_{mn} = \sum_{ijkl} Q^{b1}_{ijkl} R_{ijklmn}+ \sum_{ijkl} R^{b3}_{ijlkmn}Q^{b2}_{ijkl}.
\label{eqn:Xexample}
\end{equation} 
Note that the $l$ and $k$ indexes on $R$ have been interchanged. \\

\noindent A straight forward way to calculate this is by the following two tasks:
\begin{equation*}
\text{task A1\ : \ \ \  \ } X_{mnop} = \sum_{ijkl}  Q^{b1}_{ijkl}R^{b3}_{ijklmn},
\end{equation*}                                                             
\begin{equation*}                                                           
\text{task A2\ : \ \ \  \ } X_{mnop} += \sum_{ijkl} Q^{b2}_{ijlk}R^{b3}_{ijklmn}.
\end{equation*}
where the indexes on $Q^{b2}$ have been swapped to avoid the swapping the indexes on $R$.
Applying symmetry we end up with three tasks, but don't need to store $Q^{b2}$, i.e., 
\begin{equation*}
\text{task B1\ : \ \ \  \ } X_{mnop} = \sum_{ijkl}  Q^{b1}_{ijkl}R^{b3}_{ijklmn}
\end{equation*}                                                             
\begin{equation*}                                                           
\text{task B2\ : \ \ \  \ } Q^{b2}_{ijkl} = - (\text{swap}(k,l)[ Q^{b1}_{ijkl}])
\end{equation*}
\begin{equation*}                                                           
\text{task B3\ : \ \ \  \ } X_{mnop} += \sum_{ijkl} Q^{b2}_{ijkl}R^{b3}_{ijlkmn}
\end{equation*}
However, this saves on storage, not computation time. A better approach would be
\begin{equation*}                                                           
\text{task D1\ : \ \ \  \ } A^{b1}_{ijkl} =  Q^{b1}_{ijkl} + \rho\text{swap}(k,l)[Q^{b1}_{ijkl}]
\end{equation*}
\begin{equation*}                                                           
\text{task D2\ : \ \ \  \ } X_{mnop} = \sum_{ijkl} A^{b1}_{ijkl}R^{b3}_{ijklmn}.
\end{equation*}
This could be improved even further to
\begin{equation*}                                                           
\text{task E1\ : \ \ \  \ } X_{mnop} = \sum_{ijkl} (1+\rho) Q^{b1}_{ijkl}R^{b3}_{ijklmn}.
\end{equation*}
\noindent Getting to this final task list, containing just task E1, can be
extremely beneficial, not only because we can often replace several transposes
and summations with a single scalar multiplication, but also because if $\rho =
-1$, then no computation needs to be performed at all.\\  

\noindent To go from tasks $A1$ and $A2$ to tasks $D1$ and $D2$ all that is
required is that whenever the program wants the data for tensor block $Q^{b2}$,
it instead fetches the data for $Q^{b2}$ and performs the appropriate
transformation. However, ensuring that tasks $D1$ and $D2$ are replaced by task
$E1$ requires some more careful consideration of how the task list is constructed. 
\end{document}
